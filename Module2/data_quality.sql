
-- 4.1 Проверка количества записей между источником и приемником

/*
ОПИСАНИЕ ЛОГИКИ:
- Сравнение общего количества записей в исходной таблице заказов и фактовой таблице
- Проверка, что все данные корректно перенесены из STG в DW слой
- Ожидается одинаковое количество записей (9994 строки)

ОСОБЕННОСТИ РЕАЛИЗАЦИИ:
- Используется простой COUNT(*) для точного подсчета
- Результаты должны совпадать для подтверждения целостности ETL процесса
*/

-- Проверка количества записей в источнике (stg.orders)
SELECT COUNT(*) AS source_records_count FROM stg.orders;
-- Ожидаемый результат: 9994 записей

-- Проверка количества записей в приемнике (dw.sales_fact)
SELECT COUNT(*) AS target_records_count FROM dw.sales_fact;
-- Ожидаемый результат: 9994 записей (должен совпадать с источником)


-- 4.2 Проверка распределения данных по категориям продуктов

/*
ОПИСАНИЕ ЛОГИКИ:
- Анализ распределения продуктов по категориям в измерении продуктов
- Проверка корректности классификации и наполнения категорий
- Выявление потенциальных аномалий в распределении

ОБОСНОВАНИЕ ТИПОВ ДАННЫХ:
- category: VARCHAR(15) - текстовое представление категории продукта
- product_count: INTEGER - счетчик продуктов в каждой категории

ОСОБЕННОСТИ РЕАЛИЗАЦИИ:
- GROUP BY по категориям для анализа распределения
- COUNT(*) подсчитывает общее количество продуктов в каждой категории
*/

SELECT 
    category,  -- VARCHAR(15) - категория продукта
    COUNT(*) AS product_count  -- INTEGER - количество продуктов в категории
FROM dw.product_dim
GROUP BY category
ORDER BY product_count DESC;
-- Ожидаемое распределение: Furniture, Office Supplies, Technology


-- 4.3 Проверка отсутствия дубликатов в измерении клиентов

/*
ОПИСАНИЕ ЛОГИКИ:
- Поиск дубликатов по бизнес-ключу customer_id
- Проверка уникальности клиентов в измерении
- HAVING COUNT(*) > 1 фильтрует только дублирующиеся записи

ОСОБЕННОСТИ РЕАЛИЗАЦИИ:
- Группировка по customer_id (бизнес-ключ)
- HAVING условие отбирает только группы с более чем одной записью
- Ожидается пустой результат (отсутствие дубликатов)
*/

SELECT 
    customer_id,  -- VARCHAR(8) - бизнес-идентификатор клиента
    COUNT(*) AS duplicate_count  -- INTEGER - количество дубликатов
FROM dw.customer_dim
GROUP BY customer_id  -- Группировка по бизнес-ключу
HAVING COUNT(*) > 1;  -- Фильтрация дубликатов
-- Ожидаемый результат: 0 строк (отсутствие дубликатов)


-- 4.4 Проверка ссылочной целостности между фактами и измерением клиентов

/*
ОПИСАНИЕ ЛОГИКИ:
- Проверка корректности связей между фактовой таблицей и измерением клиентов
- LEFT JOIN с условием IS NULL выявляет "сиротские" записи
- COUNT(*) подсчитывает количество проблемных записей

ОСОБЕННОСТИ РЕАЛИЗАЦИИ:
- LEFT JOIN сохраняет все записи из фактовой таблицы
- WHERE c.cust_id IS NULL отбирает записи без соответствия в измерении
- Ожидается 0 записей (полная ссылочная целостность)
*/

SELECT COUNT(*) AS orphaned_records_count
FROM dw.sales_fact f
LEFT JOIN dw.customer_dim c ON f.cust_id = c.cust_id  -- LEFT JOIN для выявления разрывов
WHERE c.cust_id IS NULL;  -- Условие для "сиротских" записей
-- Ожидаемый результат: 0 (все записи имеют корректные ссылки)


-- РАЗДЕЛ 5: КОРРЕКТНОСТЬ РАСЧЕТОВ

-- 5.1 Проверка корректности агрегатов - сравнение исходных данных и DW

/*
ОПИСАНИЕ ЛОГИКИ:
- Сравнение ключевых финансовых метрик между источником и целевой моделью
- Проверка точности трансформации данных в ETL процессе
- Суммы должны полностью совпадать между двумя слоями

ОБОСНОВАНИЕ ТИПОВ ДАННЫХ:
- total_sales: NUMERIC(9,4) - точное совпадение типов с исходными данными
- total_profit: NUMERIC(21,16) - высокая точность для финансовых расчетов

ОСОБЕННОСТИ РЕАЛИЗАЦИИ:
- SUM(sales) и SUM(profit) вычисляются независимо в каждом слое
- Результаты должны быть идентичными для подтверждения корректности ETL
*/

-- Агрегаты из исходных данных (stg.orders)
SELECT
    SUM(sales) as total_sales,        -- NUMERIC(9,4) - общая выручка
    SUM(profit) as total_profit       -- NUMERIC(21,16) - общая прибыль
FROM stg.orders;

-- Агрегаты из целевой модели (dw.sales_fact)
SELECT
    SUM(sales) as total_sales,        -- NUMERIC(9,4) - общая выручка
    SUM(profit) as total_profit       -- NUMERIC(21,16) - общая прибыль
FROM dw.sales_fact;
-- Ожидаемый результат: суммы должны полностью совпадать


-- 5.2 Проверка контрольных сумм для ключевых метрик

/*
ОПИСАНИЕ ЛОГИКИ:
- Вычисление контрольных сумм для основных бизнес-показателей
- Проверка целостности данных через хэш-функции
- MD5 обеспечивает уникальное представление набора данных

ОСОБЕННОСТИ РЕАЛИЗАЦИИ:
- CONCAT и CAST преобразуют числовые значения в строки для хэширования
- MD5 создает уникальную сигнатуру набора метрик
- Сравнение хэшей между слоями подтверждает идентичность данных
*/

-- Контрольная сумма исходных данных
SELECT 
    MD5(CONCAT(
        CAST(COUNT(*) AS VARCHAR),
        CAST(SUM(sales) AS VARCHAR),
        CAST(SUM(profit) AS VARCHAR),
        CAST(SUM(quantity) AS VARCHAR)
    )) AS source_checksum
FROM stg.orders;

-- Контрольная сумма целевых данных
SELECT 
    MD5(CONCAT(
        CAST(COUNT(*) AS VARCHAR),
        CAST(SUM(sales) AS VARCHAR),
        CAST(SUM(profit) AS VARCHAR),
        CAST(SUM(quantity) AS VARCHAR)
    )) AS target_checksum
FROM dw.sales_fact;
-- Ожидаемый результат: идентичные хэш-суммы


-- 5.3 Дополнительная проверка: распределение по регионам

/*
ОПИСАНИЕ ЛОГИКИ:
- Сравнение распределения заказов по регионам между источником и приемником
- Проверка корректности географической классификации
- Подтверждение правильности работы ETL с измерениями

ОСОБЕННОСТИ РЕАЛИЗАЦИИ:
- Группировка по Region в источнике и geo_dim в приемнике
- JOIN через географическое измерение для сопоставимости данных
- COUNT(DISTINCT) обеспечивает точный подсчет уникальных заказов
*/

-- Распределение по регионам в источнике
SELECT 
    Region, 
    COUNT(DISTINCT Order_ID) AS order_count
FROM stg.orders 
GROUP BY Region 
ORDER BY order_count DESC;

-- Распределение по регионам в приемнике
SELECT 
    g.state AS region,  -- Используем state как аналог Region
    COUNT(DISTINCT f.order_id) AS order_count
FROM dw.sales_fact f
JOIN dw.geo_dim g ON f.geo_id = g.geo_id
GROUP BY g.state
ORDER BY order_count DESC;
-- Ожидаемый результат: сопоставимое распределение